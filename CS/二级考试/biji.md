2021-9-10

在赋值表达式中，赋值号的右边可以是变量，也可以是任意表达式
f：空语句就是指程序中的空行
多重链表一定是非线性结构
### 编译过程
C语言的可执行程序是由一系列机器指令组成的，用C语言编写的源程序必须经过编译生成二进制目标代码，再经过连接才能运行，并且可以脱离C语言集成开发环境。

编译预处理命令行：以#号开头，结尾不加分号
预处理命令可以放在程序中的任何位置
在编译之前处理
#define N 100 在编译程序对C源程序进行预处理时用100替换标识符N
#define S(x) 4*(x)*x+1
S(k+j)=4*(k+j)*k+j+1

C语言程序总是从main函数开始执行


### 基础语法
凡未指定存储类别的局部变量的隐含存储类别是自动auto
常量：0101=65,0x41=65，'\101'='65'八进制转义，'\x41'='65'十六进制转义，
浮点，实型，实数，浮点数：2.3026可以表示为0.23026E1、2.3026e0、23.026e-1，前后不能空，且e或E后面的指数必须为整数
字符：''只能包含一个字母，字符0-'0','\"'或'"'("字符)，
字符串：""(末尾自动添加空字符0（ascii为0）：'\0',a!='\0')
false:'aa'，9.12E，
double s = 1.0/t
scanf double只能用%lf

运算符号:
a+b=1,不能赋值给表达式
a=(b=4)=3,a=4=3,放回值
a += a-= a*a
先算a*a（结果为9，此时a的值没变，还是3）；
然后算 a-=a*a，等效于 a = a - 9;（结果为-6，因为赋值符号，此时a的值为-6，发生了改变）；
最后算a = a + a ，结果为-12

for(i=0,k=1;k=1;k++)//infinity
for(i=0,k==1;k=1;k++)//1

数组：
数组赋值：
```c
int a[3] = {1,2,3}
int a[3]
int a[2][1] = {{1},{2}}
int a[2][1] = {1,2}
默认值为0
int a[][2] = {1,2,3,4}//自动算出有两行
int a[][1] = {{1}，{}，{3}}
a[0] = 1
int a[8]={0}
yes：
char str[10] = "xxx"
char str[][20]={"One*World","One*Dream！"};
str[0]==One*World
strcpy(str1,str2)
str1[0] = 'x', str[1] = '\0'
char* string = "xxx"
char str[]={'\064'}//要字符串

no：
str = "xxx"//str如果是指针则可以
str1 = str2
```
arr数组首元素地址，arr+1第二个元素地址
&arr整个数组地址=arr，&arr+1最后一个元素的下一个地址
&arr[0]=arr

函数:
在c程序的函数中不能定义另一个函数
scanf():
遇到空格停止
字符型数据和数值型数据的输入可以加入任意的空格,回车和跳格
scanf("%s%s",str1,str2);//"hello world"
printf("%s%s\n",str1,str2);//"helloworld"
    456<空格>789<空格>123<回车>
    scanf("%c",&c);
    scanf("%d",&i);
    scanf("%s",&m);
    4,56,789
    scanf("%d%c%d%c",&a1,&c1,&a,&c2);//10X 20Y

gets():
可以读入除回车之外的空白符(包括空格、制表符)
如果读入回车，把回车替换为\0并结束该字符串
当 gets() 读入的第一个数据是回车，则停止继续读入，并且str 的内容就是回车。
当 gets() 读入 “hello world\n”，回车是不会被 gets() 读入的，还留在缓冲区。
gets(str1);//abc\n
gets(str2);//abc\n
str2 读到的是回车。

getchar() 读掉中间的回车，还可以在 scanf 末尾加空格

strcmp(s1，s2)
当s1<s2时，返回为负数；当s1==s2时，返回值= 0；当s1>s2时，返回正数。

### 面向对象
- 抽象性，概括性，对象是类的具体实例
- 标识唯一性，
- 对象唯一性，分类性，封装性，继承性，多态性，依赖性，模块独立性
- 复用性不是

不属于对象构成成份的是规则

### 算法
对数据进行压缩存储会降低算法的空间复杂度
快排：两边哨兵往中间走，m(m-1)/2
堆排序：nlogn
算法的时间复杂度与运行算法时特定的输入有关
希尔排序：定差值比大小，逐渐减小差值
每经过一次数据交换后能消除多个逆序


### 数据结构
怎么快速算出中序序列

循环队列中共rear－front＋max个元素

栈 s(1:m),底1，口m，初始状态为top=m+1，现经过一系列入栈与退栈运算后，top=20，则当前栈中的元素个数为m-19。压入新元素则top向下移动一层。特殊法m=19，规律法压入第一个元素，第二个，第三个。

带链栈：
带链栈的栈底指针是随栈的操作而动态变化的

某带链的队列初始状态为 front=rear=NULL 。经过一系列正常的入队与退队操作后， front=rear=10 。该队列中的元素个数为1
往队列的队尾插入一个元素为入队，从队列的排头删除一个元素称为退队。初始时 front=rear=0 ， front 总是指向队头元素的前一位置，入队一次 rear+1 ，退队一次 front+1 。队列队头队尾指针相同时队列为空。而带链的队列，由于每个元素都包含一个指针域指向下一个元素，当带链队列为空时 front=rear=Null ，插入第 1 个元素时， rear+1 指向该元素， front+1 也指向该元素，插入第 2 个元素时 rear+1 ， front 不变，删除 1 个元素时 front+1 。即 front=rear 不为空时带链的队列中只有一个元素。

top=bottom栈中的元素个数为0或1
带链栈就是没有附加头结点、运算受限的单链表。栈顶指针就是链表的头指针。如果栈底指针指向的存储单元中存有一个元素，则当top=bottom时，栈中的元素个数为1；如果栈底指针指向的存储单元中没有元素，则当top=bottom时，栈中的元素个数为0。

某带链栈的初始状态为top=bottom=NULL，经过一系列正常的入栈与退栈操作后，top=10，bottom=20。该栈中的元素个数为不确定
链表中的元素存储在不连续的地址中，因此当top=10，bottom=20时，不能确定栈中元素的个数。

front=rear=NULL带链队列空

有的二叉树也能用顺序存储结构表示
- 具有两个根结点的数据结构一定属于非线性结构
- 具有两个以上叶子结点的数据结构一定属于非线性结构
- 具有一个根结点且只有一个叶子结点的数据结构也可能是非线性结构

### 图
PAD，N-S，E-R，程序流程图，

E-R图不能用于描述算法

数据流程图（DFD图）不能作为软件设计工具
“数据流”应有有数据流名
①对加工处理建立唯一、层次性的编号,且每个加工处理通常要求既有输入又有输出;
②数据存储之间不应有数据流;
③数据流图的一致性,即输入输出、读写的对应;
④父图、子图关系与平衡规则,相邻两层DFD之间具有父子关系,子图代表了父图中某个加工的详细描述,父图表示了子图间的接口。子图个数不大于父图中的处理个数。所有子图的输入、输出数据流和父图中相应处理的输入、输出数据流必须一致

结构图：深度，宽度，最大扇入数，最大扇出数直接数

### 软件生存周期
软件是逻辑实体，具有抽象性
软件工程的三要素是方法、工具和过程

可行性研究与计划-需求分析-总体设计-详细设计-软件设计（怎么做）-集成测试-确认测试-使用维护
软件的需求分析不属于软件设计阶段任务
需求分析阶段产生的重要文档：软件需求规格阐明书
软件需求分析阶段任务:需求获取,需求分析,需求评审(f：需求配置)
软件设计是将软件需求转换为软件表达的过程
数据构造与数据库设计是软件设计的任务之一
PAD图是软件具体设计的表达工具
软件设计中模块划分应遵循高内聚低耦合的准则
软件测试是软件质量保证的重要手段

### 结构化程序设计风格

>自顶向下、逐步求精及程序设计方法
    “自顶而下，逐步求精”的设计思想，其出发点是从问题的总体目标开始，然后再一层一层地分解和细化。避免陷入复杂的细节中，简明设计过程，正确可靠的结果。

>模块化：使用三种基本控制结构构造程序，任何程序都可由顺序、选择、循环三种基本控制结构构造。
    主张使用顺序、选择、循环三种基本结构来嵌套连结成具有复杂层次的“结构化程序”，严格控制GOTO语句的使用（注意并非禁止使用）。

　　a. 以控制结构为单位，只有一个入口，一个出口。

　　b. 能够以控制结构为单位，从上到下顺序地阅读程序文本。

　　c.由于程序的静态描述与执行时的控制流程容易对应，所以能够方便正确地理解程序的操作。

>结构化程序设计主要强调的是程序的易读性。

>“独立功能，单出、入口”的模块结构，减少模块的相互联系使模块可作为插件木使用，降低程序的复杂性，提高可靠性。程序编写时，所有模块的功能通过相应的子程序(函数或过程)的代码来实现。程序的主体是子程序层次库，它与功能模块的抽象层次相对应，编码原则使得程序流程简洁、清晰，增强可读性。

>执行效率不考率

## 数据库

### 基本概念
实体：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。

属性：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。

元组：表中的一行就是一个元组。

分量：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。

码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。

全码：如果一个码包含了所有的属性，这个码就是全码。

主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。

非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。

外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。

###
三级模式体系结构的划分有利于保持数据库的数据独立性
逻辑模型是面向数据库系统的模型，有关系模型

按照传统的数据模型分类，数据库系统可分为层次、网状和关系
关系模型中的三类完整性约束：实体完整性、参照完整性和用户定义完整性
数据操纵语言负责数据库中查询操作
数据能共享且独立性高
在数据库中，产生数据不一致的根本原因是数据冗余
规范化主要为克服数据库逻辑结构中的插入异常，删除异常以及冗余度大的问题

### 关系运算
集合运算符：并，差，交，笛卡尔积
专门的关系运算符：选择，投影，链接，除


### 依赖

函数依赖
- 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。
- 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等
- 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。

#### 完全函数依赖
定义：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。

>学号->姓名

#### 部分函数依赖
定义：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。

>在关系R(学号 ,宿舍, 费用)中，(学号)->(宿舍),宿舍！=学号，(宿舍)->(费用),费用!=宿舍

#### 传递函数依赖
设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X


### 范式

#### 第一范式

第一范式列不能再分。

#### 第二范式
建立在第一范式基础上，非主属性完全依赖于码,消除部分函数依赖。


#### 第三范式
建立在第二范式基础上,消除传递函数依赖。



















## 位运算符
| 符号 | 描述 | 运算规则|
|------|------|---------|
| &    | 与   | 两个位都为1时，结果才为1 |
| |   | 或   | 两个位都为0时，结果才为0|
| ^    | 异或 | 两个位相同为0，相异为1 |
| ~    | 取反 | 0变1，1变0 |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0 |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

交换两个变量的值，不允许用临时变量，是^

#### 按.位与运算符 &
定义：参加运算的两个数据，按二进制位进行"与"运算。
运算规则：0&0=0  0&1=0  1&0=0  1&1=1
总结：两位同时为1，结果才为1，否则结果为0。

例如：3&5 即 0000 0011& 0000 0101 = 0000 0001，因此 3&5 的值得1。

注意：负数按补码形式参加按位与运算。

与运算的用途：

1）清零

如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。

2）取一个数的指定位

比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。

3）判断奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

#### 按.位或运算符 |

定义：参加运算的两个对象，按二进制位进行"或"运算。
运算规则：0|0=0  0|1=1  1|0=1  1|1=1
总结：参加运算的两个对象只要有一个为1，其值为1。

例如：3|5即 0000 0011| 0000 0101 = 0000 0111，因此，3|5的值得7。　

注意：负数按补码形式参加按位或运算。

或运算的用途

常用来对一个数据的某些位设置为1

比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。

#### 异或运算符 ^

定义：参加运算的两个数据，按二进制位进行"异或"运算。

运算规则：

0^0=0  0^1=1  1^0=1  1^1=0
总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。

异或的几条性质:

1、交换律
2、结合律 (a^b)^c == a^(b^c)
3、对于任何数x，都有 x^x=0，x^0=x
4、自反性: a^b^b=a^0=a;

异或运算的用途：

1）翻转指定位

比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

2）与0相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

3）交换两个数

void Swap(int &a, int &b){
    if (a != b){
        a ^= b;
        b ^= a;
        a ^= b;
    }
}

#### 取反运算符 ~

定义：参加运算的一个数据，按二进制进行"取反"运算。

运算规则：　

~1=0
~0=1
总结：对一个二进制数按位取反，即将0变1，1变0。

取反运算的用途：
使一个数的最低位为零

使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

#### 左移运算符 <<

定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

#### 右移运算符 >>

定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。

操作数每右移一位，相当于该数除以2。

#### 

不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以"与运算"为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，

1）如果整型数据为正数，左边补16个0。
2）如果整型数据为负数，左边补16个1。
3）如果整形数据为无符号数，左边也补16个0。
如：long a=123；int b=1；计算a& b。
如：long a=123；int b=-1；计算a& b。

如：long a=123；unsigned intb=1；计算a & b。

## 数据流和缓冲区
### 数据流
就C程序而言，从程序移进，移出字节，这种字节流就叫做流。程序与数据的交互是以流的形式进行的。进行C语言文件的读写时，都会先进行“打开文件”操作，这个操作就是在打开数据流，而“关闭文件”操作就是关闭数据流。
### 缓冲区
在程序执行时，所提供的额外内存，可用来暂时存放准备执行的数据。它的设置是为了提高存取效率，因为内存的存取速度比磁盘驱动器快得多。
当使用标准I/O函数(包含在头文件stdio.h中)时，系统会自动设置缓冲区，并通过数据流来读写文件。当进行文件读取时，是先打开数据流，将磁盘上的文件信息拷贝到缓冲区内，然后程序再从缓冲区中读取所需数据。事实上，当写入文件时，并不会马上写入磁盘中，而是先写入缓冲区，只有在缓冲区已满或“关闭文件”时，才会将数据写入磁盘。

## 文件操作

当对文件的读操作完成之后，必须将它关闭，否则可能导致数据丢失
### 文件类型
- 文本文件是以字符编码的方式进行保存的。
- 二进制文件将内存中的数据原封不动的进行保存，适用于非字符为主的数据。
其实，所有的数据都可以算是二进制文件。二进制文件的优点在于存取速度快，占用空间小。
### 文件存取方式

- 顺序存取就是从上往下，一笔一笔读取文件的内容。写入数据时，将数据附加在文件的末尾。这种存取方式常用于文本文件。
- 随机存取方式多半以二进制文件为主。它会以一个完整的单位来进行数据的读取和写入，通常以结构为单位。

### 什么是文件呢？
文件是一段数据的集合，这些数据可以是有规则的，也可以是无序的集合。在stdio.h有一个非常重要的东西，文件指针，每个文件都会在内存中开辟一块空间，用于存放文件的相关信息，这些信息保存在一个结构体中：

### 文件操作标准库函数

    “r”：以只读的形式打开文本文件(不存在则出错)
    “w”：以只写的形式打开文本文件(若不存在则新建，反之，则从文件起始位置写，覆盖原内容)
    “a”：以追加的形式打开文本文件(若不存在，则新建；反之，在原文件后追加)
    “r+”:以读写的形式打开文本文件(读时，从头开始；写时，追加写)

    “wb”： 以只写的形式打开二进制文件
    “rb”： 以只读的形式打开二进制文件
    “ab”： 以追加的形式打开二进制文件
    “rb+”：以读写的形式打开二进制文件

    “w+”：首先建立一个新文件，进行写操作，然后从头开始读(若文件存在，原内容将全部消失)
    “a+”：功能与”a”相同。只是在文件尾部追加数据后，可以从头开始读
    “wb+”：功能与”w+”相同。只是在读写时，可以由位置函数设置读和写的起始位置
    “ab+”：功能与”a+”相同。只是在文件尾部追加数据之后，可以由位置函数设置开始读的起始位置


- filename：文件的路径
- mode：打开模式
- stream：流
  
FILE* f

FILE *fopen( const char *filename, const char *mode )//打开文件
f = fopen("file.txt", "w")

int fclose( FILE *stream )//关闭文件
fclose(f)

读取字符
int fgetc ( FILE * stream )
c = fgetc (f); // 获取一个字符

写入字符
int fputc( int c, FILE *stream );
fputc(c, f)

读取字符串
char * fgets ( char * str, int num, FILE * stream )

str：将读取到的内容复制到的目标字符串
num：一次读取的大小

fgets(arr, 9, stdin)


写入字符串
int fputs( const char *string, FILE *stream )
fputs(buf, stout)

读取数据块
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );

ptr：目标内存块
size：一次读取的字节大小
count：一次读取多少个 size
stream：流

写入数据块
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream )

文件指针重定位
int fseek ( FILE * stream, long int offset, int origin );

offset：相对应 origin 位置处的偏移量，单位为字节
origin：指针的位置

#define SEEK_CUR 1 // 当前位置
#define SEEK_END 2 // 末尾
#define SEEK_SET 0 // 开头