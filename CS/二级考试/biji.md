

数组赋值：
```c
int a[3] = {1,2,3}
int a[3]
a[0] = 1
int a[2][1] = {{1},{2}}
int a[2][1] = {1,2}
默认值为0
int a[][2] = {1,2,3,4}//自动算出有两行
int a[][1] = {{1}，{}，{3}}
int a[8]={0}

```
```c
yes：
char str[10] = "xxx"
strcpy(str1,str2)
str1[0] = 'x', str[1] = '\0'
char* string = "xxx"

no：
str = "xxx"//str如果是指针则可以
str1 = str2
```

### 零散
strcmp(s1，s2)
当s1<s2时，返回为负数；
当s1==s2时，返回值= 0；
当s1>s2时，返回正数。

a += a-= a*a
先算a*a（结果为9，此时a的值没变，还是3）；
然后算 a-=a*a，等效于 a = a - 9;（结果为-6，因为赋值符号，此时a的值为-6，发生了改变）；
最后算a = a + a ，结果为-12

栈 s(1:m),底1，口m，初始状态为top=m+1，现经过一系列入栈与退栈运算后，top=20，则当前栈中的元素个数为m-19。压入新元素则top向下移动一层。特殊法m=19，规律法压入第一个元素，第二个，第三个。

软件工程的三要素是方法、工具和过程
软件是逻辑实体，具有抽象性
软件测试是软件质量保证的重要手段
带链栈的栈底指针是随栈的操作而动态变化的
软件设计中模块划分应遵循高内聚低耦合的准则
凡是以#号开头的行，都被称为编译预处理命令行
浮点/实型常量又称实数或浮点数
2.3026可以表示为0.23026E1、2.3026e0、23.026e-1，字母e或E之前必须要有数字，且e或E后面的指数必须为整数



数据流程图（DFD图）不能作为软件设计工具
#define N 100 在编译程序对C源程序进行预处理时用100替换标识符N

- 具有两个根结点的数据结构一定属于非线性结构
- 具有两个以上叶子结点的数据结构一定属于非线性结构
- 具有一个根结点且只有一个叶子结点的数据结构也可能是非线性结构

### 结构图
深度，宽度，最大扇入数，最大扇出数直接数

### 图
PAD，N-S，E-R，程序流程图

### 软件生存周期
可行性研究与计划-需求分析-总体设计-详细设计-软件设计（怎么做）-集成测试-确认测试-使用维护
软件的需求分析不属于软件设计阶段任务


### 结构化程序设计风格

>采用自顶向下、逐步求精及模块化的程序设计方法
    2）“自顶而下，逐步求精”的设计思想，其出发点是从问题的总体目标开始，抽象低层的细节，先专心构造高层的结构，然后再一层一层　　地分解和细化。这使设计者能把握主题，高屋建瓴，避免一开始就陷入复杂的细节中，使复杂的设计过程变得简单明了，过程的结果也容易做到正确可靠。

>使用三种基本控制结构构造程序，任何程序都可由顺序、选择、循环三种基本控制结构构造。
    主张使用顺序、选择、循环三种基本结构来嵌套连结成具有复杂层次的“结构化程序”，严格控制GOTO语句的使用（注意并非禁止使用）。

    这样编出的程序在结构上具有以下效果：

　　a. 以控制结构为单位，只有一个入口，一个出口。

　　b. 能够以控制结构为单位，从上到下顺序地阅读程序文本。

　　c.由于程序的静态描述与执行时的控制流程容易对应，所以能够方便正确地理解程序的操作。

>结构化程序设计主要强调的是程序的易读性。

>“独立功能，单出、入口”的模块结构，减少模块的相互联系使模块可作为插件或积木使用，降低程序的复杂性，提高可靠性。程序编写时，所有模块的功能通过相应的子程序(函数或过程)的代码来实现。程序的主体是子程序层次库，它与功能模块的抽象层次相对应，编码原则使得程序流程简洁、清晰，增强可读性。

>执行效率不考率

## 数据库

### 基本概念
实体：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。

属性：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。

元组：表中的一行就是一个元组。

分量：元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。

码：表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。

全码：如果一个码包含了所有的属性，这个码就是全码。

主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性。

非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。

外码：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。

###
三级模式体系结构的划分有利于保持数据库的数据独立性
逻辑模型是面向数据库系统的模型，有关系模型

按照传统的数据模型分类，数据库系统可分为层次、网状和关系

### 关系运算
集合运算符：并，差，交，笛卡尔积
专门的关系运算符：选择，投影，链接，除


### 依赖

函数依赖
- 设R(U)是一个属性集U上的关系模式，X和Y是U的子集。
- 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等
- 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。

#### 完全函数依赖
定义：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。

>学号->姓名

#### 部分函数依赖
定义：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。

>在关系R(学号 ,宿舍, 费用)中，(学号)->(宿舍),宿舍！=学号，(宿舍)->(费用),费用!=宿舍

#### 传递函数依赖
设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X


### 范式

#### 第一范式

第一范式列不能再分。

#### 第二范式
建立在第一范式基础上，非主属性完全依赖于码,消除部分函数依赖。


#### 第三范式
建立在第二范式基础上,消除传递函数依赖。


#### 面向对象主要特征
- 抽象性，概括性，对象是类的具体实例
- 标识唯一性，
- 对象唯一性，分类性，封装性，继承性，多态性，依赖性，模块独立性
- 复用性不是
















## 位运算符
| 符号 | 描述 | 运算规则                                                                                                                     |
|------|------|------------------------------------------------------------------------------------------------------------------------------|
| &    | 与   | 两个位都为1时，结果才为1                                                                                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                                                                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                                                                                       |
| ~    | 取反 | 0变1，1变0                                                                                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                                                                                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |


#### 按.位与运算符 &#
定义：参加运算的两个数据，按二进制位进行"与"运算。
运算规则：0&0=0  0&1=0  1&0=0  1&1=1
总结：两位同时为1，结果才为1，否则结果为0。

例如：3&5 即 0000 0011& 0000 0101 = 0000 0001，因此 3&5 的值得1。

注意：负数按补码形式参加按位与运算。

##### 与运算的用途：

1）清零

如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。

2）取一个数的指定位

比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。

3）判断奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

#### 按.位或运算符 |

定义：参加运算的两个对象，按二进制位进行"或"运算。
运算规则：0|0=0  0|1=1  1|0=1  1|1=1
总结：参加运算的两个对象只要有一个为1，其值为1。

例如：3|5即 0000 0011| 0000 0101 = 0000 0111，因此，3|5的值得7。　

注意：负数按补码形式参加按位或运算。

##### 或运算的用途

常用来对一个数据的某些位设置为1

比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。

#### 异或运算符 ^

定义：参加运算的两个数据，按二进制位进行"异或"运算。

运算规则：

0^0=0  0^1=1  1^0=1  1^1=0
总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。

异或的几条性质:

1、交换律
2、结合律 (a^b)^c == a^(b^c)
3、对于任何数x，都有 x^x=0，x^0=x
4、自反性: a^b^b=a^0=a;

##### 异或运算的用途：

1）翻转指定位

比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

2）与0相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

3）交换两个数

void Swap(int &a, int &b){
    if (a != b){
        a ^= b;
        b ^= a;
        a ^= b;
    }
}

#### 取反运算符 ~

定义：参加运算的一个数据，按二进制进行"取反"运算。

运算规则：　

~1=0
~0=1
总结：对一个二进制数按位取反，即将0变1，1变0。

##### 异或运算的用途：
使一个数的最低位为零

使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

#### 左移运算符 <<

定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

#### 右移运算符 >>

定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。

操作数每右移一位，相当于该数除以2。

#### 复合赋值运算符

位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：

&=        例：a&=b    相当于     a=a&b

|=        例：a|=b    相当于     a=a|b

>>=      例：a>>=b   相当于     a=a>>b

<<=      例：a<<=b     相当于      a=a<<b

^=        例：a^=b    相当于   a=a^b
运算规则：和前面讲的复合赋值运算符的运算规则相似。

不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。

以"与运算"为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，

1）如果整型数据为正数，左边补16个0。
2）如果整型数据为负数，左边补16个1。
3）如果整形数据为无符号数，左边也补16个0。
如：long a=123；int b=1；计算a& b。
如：long a=123；int b=-1；计算a& b。

如：long a=123；unsigned intb=1；计算a & b。

## 数据流和缓冲区
### 数据流
就C程序而言，从程序移进，移出字节，这种字节流就叫做流。程序与数据的交互是以流的形式进行的。进行C语言文件的读写时，都会先进行“打开文件”操作，这个操作就是在打开数据流，而“关闭文件”操作就是关闭数据流。
### 缓冲区
在程序执行时，所提供的额外内存，可用来暂时存放准备执行的数据。它的设置是为了提高存取效率，因为内存的存取速度比磁盘驱动器快得多。
当使用标准I/O函数(包含在头文件stdio.h中)时，系统会自动设置缓冲区，并通过数据流来读写文件。当进行文件读取时，是先打开数据流，将磁盘上的文件信息拷贝到缓冲区内，然后程序再从缓冲区中读取所需数据。事实上，当写入文件时，并不会马上写入磁盘中，而是先写入缓冲区，只有在缓冲区已满或“关闭文件”时，才会将数据写入磁盘。

## 文件操作

### 文件类型
- 文本文件是以字符编码的方式进行保存的。
- 二进制文件将内存中的数据原封不动的进行保存，适用于非字符为主的数据。
其实，所有的数据都可以算是二进制文件。二进制文件的优点在于存取速度快，占用空间小。
### 文件存取方式

- 顺序存取就是从上往下，一笔一笔读取文件的内容。写入数据时，将数据附加在文件的末尾。这种存取方式常用于文本文件。
- 随机存取方式多半以二进制文件为主。它会以一个完整的单位来进行数据的读取和写入，通常以结构为单位。

### 什么是文件呢？
文件是一段数据的集合，这些数据可以是有规则的，也可以是无序的集合。在stdio.h有一个非常重要的东西，文件指针，每个文件都会在内存中开辟一块空间，用于存放文件的相关信息，这些信息保存在一个结构体中：

## 文件操作标准库函数

    “r”：以只读的形式打开文本文件(不存在则出错)
    “w”：以只写的形式打开文本文件(若不存在则新建，反之，则从文件起始位置写，覆盖原内容)
    “a”：以追加的形式打开文本文件(若不存在，则新建；反之，在原文件后追加)
    “r+”：以读写的形式打开文本文件(读时，从头开始；写时，新数据只覆盖所占的空间)
    “wb”：以只写的形式打开二进制文件
    “rb”：以只读的形式打开二进制文件
    “ab”：以追加的形式打开一个二进制文件
    “rb+”：以读写的形式打开二进制文件。
    “w+”：首先建立一个新文件，进行写操作，然后从头开始读(若文件存在，原内容将全部消失)
    “a+”：功能与”a”相同。只是在文件尾部追加数据后，可以从头开始读
    “wb+”：功能与”w+”相同。只是在读写时，可以由位置函数设置读和写的起始位置
    “ab+”：功能与”a+”相同。只是在文件尾部追加数据之后，可以由位置函数设置开始读的起始位置


- filename：文件的路径
- mode：打开模式
- stream：流
  
FILE* f

FILE *fopen( const char *filename, const char *mode )//打开文件
f = fopen("file.txt", "w")

int fclose( FILE *stream )//关闭文件
fclose(f)

读取字符
int fgetc ( FILE * stream )
c = fgetc (f); // 获取一个字符

写入字符
int fputc( int c, FILE *stream );
fputc(c, f)

读取字符串
char * fgets ( char * str, int num, FILE * stream )

str：将读取到的内容复制到的目标字符串
num：一次读取的大小

fgets(arr, 9, stdin)


写入字符串
int fputs( const char *string, FILE *stream )
fputs(buf, stout)

读取数据块
size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );

ptr：目标内存块
size：一次读取的字节大小
count：一次读取多少个 size
stream：流

写入数据块
size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream )

文件指针重定位
int fseek ( FILE * stream, long int offset, int origin );

offset：相对应 origin 位置处的偏移量，单位为字节
origin：指针的位置

#define SEEK_CUR 1 // 当前位置
#define SEEK_END 2 // 末尾
#define SEEK_SET 0 // 开头











